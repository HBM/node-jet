<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: 2_jsonrpc/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: 2_jsonrpc/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRPC = void 0;
const errors_1 = require("../3_jet/errors");
const messages_1 = require("../3_jet/messages");
const socket_1 = require("../1_socket/socket");
const _1_socket_1 = require("../1_socket");
/**
 * Helper shorthands.
 */
const encode = JSON.stringify;
const decode = JSON.parse;
const isResultMessage = (msg) => {
    return 'result' in msg;
};
const isErrorMessage = (msg) => {
    return 'error' in msg;
};
/**
 * JsonRPC Instance
 * class used to interpret jsonrpc messages. This class can parse incoming socket messages to jsonrpc messages and fires events
 */
class JsonRPC extends _1_socket_1.EventEmitter {
    sock;
    config;
    messages = [];
    messageId = 1;
    _isOpen = false;
    openRequests = {};
    batchPromises = [];
    requestId = '';
    resolveDisconnect;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    rejectDisconnect;
    disconnectPromise;
    resolveConnect;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    rejectConnect;
    connectPromise;
    logger;
    abortController;
    sendImmediate;
    constructor(logger, config, sock) {
        super();
        this.config = config || {};
        this.sendImmediate = config?.batches ? false : true;
        this.createDisconnectPromise();
        this.createConnectPromise();
        this.logger = logger;
        if (sock) {
            this.sock = sock;
            this._isOpen = true;
            this.subscribeToSocketEvents();
        }
    }
    /**
     * Method called before disconnecting from the device to initialize Promise, that is only resolved when disconnected
     */
    createDisconnectPromise = () => {
        this.disconnectPromise = new Promise((resolve, reject) => {
            this.resolveDisconnect = resolve;
            this.rejectDisconnect = reject;
        });
    };
    /**
     * Method called before connecting to the device to initialize Promise, that is only resolved when a connection is established
     */
    createConnectPromise = () => {
        this.connectPromise = new Promise((resolve, reject) => {
            this.resolveConnect = resolve;
            this.rejectConnect = reject;
        });
    };
    /**
     * Method called to subscribe to all relevant socket events
     */
    subscribeToSocketEvents = () => {
        this.sock.addEventListener('error', this._handleError);
        this.sock.addEventListener('message', this._handleMessage);
        this.sock.addEventListener('open', () => {
            this._isOpen = true;
            this.createDisconnectPromise();
            if (this.abortController.signal.aborted) {
                this.logger.warn('user requested abort');
                this.close();
                this.rejectConnect();
            }
            else {
                this.resolveConnect();
            }
        });
        this.sock.addEventListener('close', () => {
            this._isOpen = false;
            this.resolveDisconnect();
            this.createConnectPromise();
        });
    };
    /**
     * Method to connect to a Server instance. Either TCP Server or Webserver
     * @params controller: an AbortController that can be used to abort the connection
     */
    connect = (controller = new AbortController()) => {
        if (this._isOpen) {
            return Promise.resolve();
        }
        this.abortController = controller;
        const config = this.config;
        this.sock = new socket_1.Socket();
        this.sock.connect(config.url, config.ip, config.port || 11122);
        this.subscribeToSocketEvents();
        return this.connectPromise;
    };
    /**
     * Close.
     */
    close = () => {
        if (!this._isOpen) {
            return Promise.resolve();
        }
        this.send();
        this.sock.close();
        return this.disconnectPromise;
    };
    _handleError = (err) => {
        this.logger.error(`Error in socket connection: ${err}`);
        if (!this._isOpen) {
            this.rejectConnect(err);
        }
    };
    /**
     * _dispatchMessage
     *
     * @api private
     */
    _handleMessage = (event) => {
        const message = event.data;
        this.logger.sock(`Received message: ${message}`);
        try {
            const decoded = decode(message);
            if (Array.isArray(decoded)) {
                decoded.forEach((singleMessage) => {
                    this._dispatchSingleMessage(singleMessage);
                });
            }
            else {
                this._dispatchSingleMessage(decoded);
            }
            this.send().catch((err) => {
                this.logger.error(err);
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (err) {
            this.respond('', new errors_1.ParseError(message), false);
            this.logger.error(err);
        }
    };
    /**
     * _dispatchSingleMessage
     *
     * @api private
     */
    _dispatchSingleMessage = (message) => {
        if (isResultMessage(message) || isErrorMessage(message)) {
            this._dispatchResponse(message);
        }
        else {
            this._dispatchRequest((0, messages_1.castMessage)(message));
        }
    };
    /**
     * _dispatchResponse
     *
     * @api private
     */
    _dispatchResponse = (message) => {
        const mid = message.id;
        if (isResultMessage(message)) {
            this.successCb(mid, message.result);
        }
        if (isErrorMessage(message)) {
            this.errorCb(mid, message.error);
        }
    };
    /**
     * _dispatchRequest.
     * Handles both method calls and fetchers (notifications)
     *
     * @api private
     */
    _dispatchRequest = (message) => {
        if (this.listenerCount(message.method) === 0) {
            this.logger.error(`Method ${message.method} is unknown`);
            this.respond(message.id, new errors_1.methodNotFoundError(message.method), false);
        }
        else {
            this.emit(message.method, this, message.id, message.params);
        }
    };
    /**
     * Queue.
     */
    queue = (message, id = '') => {
        if (!this._isOpen) {
            return Promise.reject(new errors_1.ConnectionClosed());
        }
        if (id) {
            this.messages.push({ method: id, params: message });
        }
        else {
            this.messages.push(message);
        }
        if (this.sendImmediate) {
            this.send();
        }
    };
    /**
     * Send.
     */
    send = () => {
        if (this.messages.length > 0) {
            const encoded = encode(this.messages.length === 1 ? this.messages[0] : this.messages);
            this.logger.sock(`Sending message:  ${encoded}`);
            this.sock.send(encoded);
            this.messages = [];
        }
        else {
            return Promise.resolve();
        }
        return Promise.all(this.batchPromises)
            .then((res) => {
            this.batchPromises = [];
            return Promise.resolve(res);
        })
            .catch((ex) => {
            this.batchPromises = [];
            this.logger.error(JSON.stringify(ex));
            return Promise.reject(ex);
        });
    };
    /**
     * Responding a request
     * @param id the request id to respond to
     * @param params the result of the request
     * @param success if the request was fulfilled
     */
    respond = (id, params, success) => {
        this.queue({ id, [success ? 'result' : 'error']: params });
    };
    successCb = (id, result) => {
        if (id in this.openRequests) {
            this.openRequests[id].resolve(result);
            delete this.openRequests[id];
        }
    };
    errorCb = (id, error) => {
        if (id in this.openRequests) {
            this.openRequests[id].reject(error);
            delete this.openRequests[id];
        }
    };
    /**
     * Method to send a request to a JSONRPC Server.
     */
    sendRequest = (method, params, immediate = undefined) => {
        const promise = new Promise((resolve, reject) => {
            if (!this._isOpen) {
                reject(new errors_1.ConnectionClosed());
            }
            else {
                const rpcId = this.messageId.toString();
                this.messageId++;
                this.openRequests[rpcId] = { resolve, reject };
                this.queue({
                    id: rpcId.toString(),
                    method,
                    params
                });
                if (immediate) {
                    this.send();
                }
            }
        });
        this.batchPromises.push(promise);
        if (immediate || this.sendImmediate)
            return promise.catch((err) => {
                this.logger.error(JSON.stringify(err));
                return Promise.reject(err);
            });
        else {
            return Promise.resolve({});
        }
    };
}
exports.JsonRPC = JsonRPC;
exports.default = JsonRPC;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="JsonRPC.html">JsonRPC</a></li><li><a href="Logger.html">Logger</a></li><li><a href="MessageSocket.html">MessageSocket</a></li><li><a href="Socket.html">Socket</a></li><li><a href="TCPServer.html">TCPServer</a></li><li><a href="WebsocketServer.html">WebsocketServer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#encode">encode</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Tue Nov 15 2022 16:23:54 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
